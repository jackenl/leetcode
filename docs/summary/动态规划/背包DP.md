# 动态规划——背包问题系列

**背包问题**（Knapsack problem）是一种[组合优化](https://zh.wikipedia.org/wiki/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96 "组合优化")的[NP完全](https://zh.wikipedia.org/wiki/NP%E5%AE%8C%E5%85%A8 "NP完全")问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。

一般来讲，背包问题有以下几种分类：

1. 0-1背包问题

2. 完全背包问题

3. 多重背包问题

## 1. 0-1 背包问题

如果限定每种物品只能选择0个或1个，则问题称为**0-1背包问题**

### 1.1 问题描述

一共有N件物品，第i（i从1开始）件物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

### 1.2 解题思路

首先定义状态dp：

```
dp[i][j]表示将前i件物品装进限重为j的背包可以获得的最大价值，0<=i<=N，0<=j<=W
```

然后将 dp[0][0,...,W] 都初始化为 0，表示没有物品时装入书包的最大价值为 0，那么当 i > 0 时 dp[i][j] 有以下两种情况：

1. 不装入第 i 件物品，最大价值为前 i-1 件物品装入限重为 j 书包的最大价值，即 dp[i-1][j]；

2. 装入第 i 件物品（前提是能装下），最大价值为前 i-1 件物品装入限重为 j - w[i] 书包的最大价值加上 v[i]，即 dp[i-1][j-w[i]] + v[i]；

得到状态转移方程：

```
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i]), j >= w[i]
```

使用滚动数组进行空间优化，得到伪代码：

```
dp[0,...,W] = 0
for i = 1,...,N
    for j = W,...w[i] // 需逆向枚举
        dp[j] = max(dp[j], dp[j-w[i]]+v[i])
```

时间复杂度为`O(NW)`，空间复杂度为`O(W)`，其中 W 是已知常量。

## 2. 完全背包问题

如果不限定每种物品的数量，则问题称为**完全背包问题**

### 2.1 问题描述

一共有N种物品，每种物品有无限多个，第i（i从1开始）种物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

### 2.2 解题思路

首先定义状态dp：

```
dp[i][j]表示将前i件物品装进限重为j的背包可以获得的最大价值, 0<=i<=N, 0<=j<=W
```

#### 2.2.1 方法1

同理将 dp[0][0,...,W] 都初始化为 0，那么当 i > 0 时 dp[i][j] 有以下两种情况：

1. 不装入第 i 种物品，最大价值为前 i-1 件物品装入限重为 j 书包的最大价值，即 dp[i-1][j]；

2. 装入第 i 种物品，由于每种物品有无限个，在装入第 i 种物品后还可以继续装入第 i 种物品，最大价值为限重为 j 书包尽可能装入第 i 件物品的价值，即 dp[i][j-w[i]] + v[i]；

得到状态转移方程：

```
dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]]+v[i]), j >= w[i]
```

使用滚动数组进行空间优化，得到伪代码：

```
dp[0,...,W] = 0
for i = 1,...,N
    for j = w[i],...,W // 需正向枚举
        dp[j] = max(dp[j], dp[j-w[i]]+v[i])
```

时间复杂度为`O(NW)`，空间复杂度为`O(W)`，其中 W 是已知常量

#### 2.2.2 方法2

假设 k 为装入第 i 种物品的件数，k <= j/w[i]，得到状态转移方程：

```
dp[i][j] = max{(dp[i-1][j − k*w[i]] + k*v[i]) for every k}
```

使用滚动数组进行空间优化，得到伪代码：

```
dp[0,...,W] = 0
for i = 1,...,N
    for j = 0,...,j/w[i] // 需逆向枚举
        for k = 0,...,j/w[i]
            dp[j] = max(dp[j], dp[j-k*w[i]]+k*v[i])
```

时间复杂度为`O(NW∑i(W/wi)`，空间复杂度为`O(W)`，其中 W 是已知常量

## 3.多重背包问题

如果都限定每种物品的数量为有限个，则问题称为**多重背包**

### 3.1 问题描述

一共有N种物品，第i（i从1开始）种物品的数量为n[i]，重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

### 3. 2解题思路

首先定义状态dp：

```
dp[i][j]表示将前i件物品装进限重为j的背包可以获得的最大价值, 0<=i<=N, 0<=j<=W
```

同理将 dp[0][0,...,W] 都初始化为 0，假设 k 为装入第 i 种物品的件数，k <= min(n[i], j/w[i])，得到状态转移方程：

```
dp[i][j] = max{(dp[i-1][j-k*w[i]] + k*v[i]) for every k}
```

使用滚动数组进行空间优化，得到伪代码：

```
dp[0,...,W] = 0
for i = 1,...,N
    for j = W,...,w[i] // 需逆向枚举
        for k = 0,...,min(n[i], j/w[i])
            dp[j] = max(dp[j], dp[j-k*w[i]]+k*v[i])
```

时间复杂度为`O(WN∑ini)`，空间复杂度为`O(W)`，其中 W 是已知常量

## 4. 其他变形

### 4.1 混合背包问题

```
for i = 1,...,N
    switch 背包问题
        case 背包问题: 对应背包求解方法
```

### 4.2 二维背包问题

```
for i = 1,...,N
    for j = U,...,u[i]
        for k = V,...,v[i]
            dp[j][k] = max(dp[j][k], dp[j-u[i]][k-v[i]] + w[i])
```

### 4.3 分组背包问题

```
for 所有的组k
    for j = W,...w[i]
        for 所有i属于组k
            dp[j] = max(dp[j], dp[j-w[i]]+v[i])
```

### 4.4 背包装满问题

```
dp[0][0] = 1
for i = 1,...,N
    for j = W,...,w[i]
        dp[j] += dp[j-w[i]]
```

### 4.5 背包问题的方案总数

```
// 容量为0时方案数为1
dp[0][0] = 1
for i = 1,...,N
    for j = W,...w[i] // 逆向枚举
        dp[j] += dp[j-w[i]]
```
