# 回溯算法问题系列

回溯是 DFS 中的一种技巧。回溯法采用 [试错](https://zh.wikipedia.org/wiki/%E8%AF%95%E9%94%99) 的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将**取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案**。

通俗上讲，回溯是一种走不通就回头的算法。

回溯的本质是穷举所有可能，尽管有时候可以通过剪枝去除一些根本不可能是答案的分支， 但是从本质上讲，仍然是一种暴力枚举算法。

回溯法可以抽象为树形结构，并且是是一颗高度有限的树（N 叉树）。回溯法解决的都是在集合中查找子集，集合的大小就是树的叉树，递归的深度，构成树的高度。

## 解题模板

伪代码：

```
function dfs(i) {
    // 找到目标结果或结尾
    if (end()) {
        return;
    }
    // 对i进行做一些操作
    do(i);
    // 遍历搜索第i节点所有能到达节点
    for (j in next(i)) {
        // 接续搜索符合节点
        if (isValid(j)) {
            dfs(j);
        } 
    }
    // 恢复i
    undo(i);
}
```

## 剪枝

回溯题目的另外一个考点是剪枝，通过剪枝避免根本不可能是答案的递归

```
for (j in next(i)) {
    // 剪枝：过滤不符合条件递归
    if (isValid(j)) {
        dfs(j);
    } 
}
```


